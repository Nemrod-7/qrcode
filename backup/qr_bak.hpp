#include <string>

// error correction level
// L : tolerate 7 % of data loss
// M : tolerate 15 % of data loss
// Q : tolerate 25 % of data loss
// H : tolerate 30 % of data loss
//
enum ECC {L, M, Q, H};

enum MODE {END, NUMERIC, ALPHANUM, STRUCTURED, BYTE, FNC1, _6_, ECI, KANJI};
// const int Mdb[4][2] = {{1, 4},{2, 6},{4, 8},{8, 16}};
const std::string alnum = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";

const unsigned int padding[2] = {0xec, 0x11}; // bin: 11101100 00010001
//                                         [         data codewords         ] [            ecc codewords             ]
// the qr binary data is encoded like this [[[mode][data length][data][0000]] [ecc block 1][ecc block 2][ecc block...]

// the message received (numeric, alphanumeric, byte or kanji) is encoded and the error correction code chosen determine the size needed and so the size of the grid.
// this table is used just to determine the version of the qr code and nothing else. : capacity[version][mode][ecc] -> maximum of encoded [data] codewords allowed .
//           0 -> 1              1 -> 2                    2 -> 4                         3 -> 8
// END,     NUMERIC,            ALPHANUM,   STRUCTURED,     BYTE,      FNC1,_6_,ECI,       KANJI
//        L   M   Q   H         L   M   Q   H           L   M   Q   H                  L   M   Q   H
const unsigned int capacity[23][9][4] = {
{{},{                    },{                    },{},{                    },{},{},{},{                    }},
{{},{  41,  34,  27,  17,},{  25,  20,  16,  10,},{},{  17,  14,  11,   7,},{},{},{},{  10,   8,   7,   4,}},
{{},{  77,  63,  48,  34,},{  47,  38,  29,  20,},{},{  32,  26,  20,  14,},{},{},{},{  20,  16,  12,   8,}},
{{},{ 127, 101,  77,  58,},{  77,  61,  47,  35,},{},{  53,  42,  32,  24,},{},{},{},{  32,  26,  20,  15,}},
{{},{ 187, 149, 111,  82,},{ 114,  90,  67,  50,},{},{  78,  62,  46,  34,},{},{},{},{  48,  38,  28,  21,}},
{{},{ 255, 202, 144, 106,},{ 154, 122,  87,  64,},{},{ 106,  84,  60,  44,},{},{},{},{  65,  52,  37,  27,}},
{{},{ 322, 255, 178, 139,},{ 195, 154, 108,  84,},{},{ 134, 106,  74,  58,},{},{},{},{  82,  65,  45,  36,}},
{{},{ 370, 293, 207, 154,},{ 224, 178, 125,  93,},{},{ 154, 122,  86,  64,},{},{},{},{  95,  75,  53,  39,}},
{{},{ 461, 365, 259, 202,},{ 279, 221, 157, 122,},{},{ 192, 152, 108,  84,},{},{},{},{ 118,  93,  66,  52,}},
{{},{ 552, 432, 312, 235,},{ 335, 262, 189, 143,},{},{ 230, 180, 130,  98,},{},{},{},{ 141, 111,  80,  60,}},
{{},{ 652, 513, 364, 288,},{ 395, 311, 221, 174,},{},{ 271, 213, 151, 119,},{},{},{},{ 167, 131,  93,  74,}},
{{},{ 772, 604, 427, 331,},{ 468, 366, 259, 200,},{},{ 321, 251, 177, 137,},{},{},{},{ 198, 155, 109,  85,}},
{{},{ 883, 691, 489, 374,},{ 535, 419, 296, 227,},{},{ 367, 287, 203, 155,},{},{},{},{ 226, 177, 125,  96,}},
{{},{1022, 796, 580, 427,},{ 619, 483, 352, 259,},{},{ 425, 331, 241, 177,},{},{},{},{ 262, 204, 149, 109,}},
{{},{1101, 871, 621, 468,},{ 667, 528, 376, 283,},{},{ 458, 362, 258, 194,},{},{},{},{ 282, 223, 159, 120,}},
{{},{1250, 991, 703, 530,},{ 758, 600, 426, 321,},{},{ 520, 412, 292, 220,},{},{},{},{ 320, 254, 180, 136,}},
{{},{1408,1082, 775, 602,},{ 854, 656, 470, 365,},{},{ 586, 450, 322, 250,},{},{},{},{ 361, 277, 198, 154,}},
{{},{1548,1212, 876, 674,},{ 938, 734, 531, 408,},{},{ 644, 504, 364, 280,},{},{},{},{ 397, 310, 224, 173,}},
{{},{1725,1346, 948, 746,},{1046, 816, 574, 452,},{},{ 718, 560, 394, 310,},{},{},{},{ 442, 345, 243, 191,}},
{{},{1903,1500,1063, 813,},{1153, 909, 644, 493,},{},{ 792, 624, 442, 338,},{},{},{},{ 488, 384, 272, 208,}},
{{},{2061,1600,1159, 919,},{1249, 970, 702, 557,},{},{ 858, 666, 482, 382,},{},{},{},{ 528, 410, 297, 235,}},
{{},{2232,1708,1224, 969,},{1352,1035, 742, 587,},{},{ 929, 711, 509, 403,},{},{},{},{ 572, 438, 314, 248,}},
{{},{2409,1872,1358,1056,},{1460,1134, 823, 640,},{},{1003, 779, 565, 439,},{},{},{},{ 618, 480, 348, 270,}} };

//
const unsigned int err_blocks [4][41] = { // err_blocks[ecc][version] -> number of [ecc blocks...].
    //  Version: (note that index 0 is for padding, and is set to an illegal value)
    //  1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    {0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low
    {0, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium
    {0, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile
    {0, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High
};

// const int eccinfo[4][17] = {
//   {0b1010001001,0b1110111110,0b0011100111,0b0111010000,0b1101100010,0b1001010101,0b0100001100,0b0000111011},
//   {0b0101011111,0b0001101000,0b1100110001,0b1000000110,0b0010110100,0b0110000011,0b1011011010,0b1111101101},
//   {0b0000010010,0b0100100101,0b1001111100,0b1101001011,0b0111111001,0b0011001110,0b1110010111,0b1010100000},
//   {0b1111000100,0b1011110011,0b0110101010,0b0010011101,0b1000101111,0b1100011000,0b0001000001,0b0101110110},
// };

// dcblocks[version] -> number of [data codewords] for each version :
//  L    M    Q    H
const unsigned int codewords[41][4] = { {    0,    0,    0,    0},
{   19,   16,   13,    9}, {   34,   28,   22,   16}, {   55,   44,   34,   26}, {   80,   64,   48,   36}, {  108,   86,   62,   46},
{  136,  108,   76,   60}, {  156,  124,   88,   66}, {  194,  154,  110,   86}, {  232,  182,  132,  100}, {  274,  216,  154,  122},
{  324,  254,  180,  140}, {  370,  290,  206,  158}, {  428,  334,  244,  180}, {  461,  365,  261,  197}, {  523,  415,  295,  223},
{  589,  453,  325,  253}, {  647,  507,  367,  283}, {  721,  563,  397,  313}, {  795,  627,  445,  341}, {  861,  669,  485,  385},
{  932,  714,  512,  406}, { 1006,  782,  568,  442}, { 1094,  860,  614,  464}, { 1174,  914,  664,  514}, { 1276, 1000,  718,  538},
{ 1370, 1062,  754,  596}, { 1468, 1128,  808,  628}, { 1531, 1193,  871,  661}, { 1631, 1267,  911,  701}, { 1735, 1373,  985,  745},
{ 1843, 1455, 1033,  793}, { 1955, 1541, 1115,  845}, { 2071, 1631, 1171,  901}, { 2191, 1725, 1231,  961}, { 2306, 1812, 1286,  986},
{ 2434, 1914, 1354, 1054}, { 2566, 1992, 1426, 1096}, { 2702, 2102, 1502, 1142}, { 2812, 2216, 1582, 1222}, { 2956, 2334, 1666, 1276} };

//  ecsize[version] -> number of [ecc codwords] needed for each block.
//  L    M    Q    H
const unsigned int ecsize[41][4] = { {   0,   0,   0,   0,},
{   7,  10,  13,  17}, {  10,  16,  22,  28}, {  15,  26,  18,  22}, {  20,  18,  26,  16}, {  26,  24,  18,  22},
{  18,  16,  24,  28}, {  20,  18,  18,  26}, {  24,  22,  22,  26}, {  30,  22,  20,  24}, {  18,  26,  24,  28},
{  20,  30,  28,  24}, {  24,  22,  26,  28}, {  26,  22,  24,  22}, {  30,  24,  20,  24}, {  22,  24,  30,  24},
{  24,  28,  24,  30}, {  28,  28,  28,  28}, {  30,  26,  28,  28}, {  28,  26,  26,  26}, {  28,  26,  30,  28},
{  28,  26,  28,  30}, {  28,  28,  30,  24}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  26,  28,  30,  30},
{  28,  28,  28,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30},
{  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30},
{  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30}, {  30,  28,  30,  30} };

// the number of bits necessary to record the size of the txt
// depends of the version and the mode :
//    N   AN    B        K
const unsigned int length_bits[3][9] = {
    {0,10, 9,0, 8,0,0,0, 8}, // version  1- 9
    {0,12,11,0,16,0,0,0,10}, // version 10-26
    {0,14,13,0,16,0,0,0,12}  // version 27-40
};

// format information string [ecc -> L,M,Q,H][mask -> 0,1,2,3,4,5,6,7] precalulated mask and ecc
const char information[4][8][16] = {
    { "111011111000100", "111001011110011", "111110110101010", "111100010011101", "110011000101111", "110001100011000", "110110001000001", "110100101110110" }, // L
    { "101010000010010", "101000100100101", "101111001111100", "101101101001011", "100010111111001", "100000011001110", "100111110010111", "100101010100000" }, // M
    { "011010101011111", "011000001101000", "011111100110001", "011101000000110", "010010010110100", "010000110000011", "010111011011010", "010101111101101" }, // Q
    { "001011010001001", "001001110111110", "001110011100111", "001100111010000", "000011101100010", "000001001010101", "000110100001100", "000100000111011" }, // H
  };

//////////////////////////////drawing patterns//////////////////////////////////




class Infos {
    public :
        static std::string ECC (int level) {
            switch(level) {
                case L : return "Low"; break;
                case M : return "Medium"; break;
                case Q : return "Quality"; break;
                case H : return "High"; break;
                default : return ""; break;
            }
        }
        static std::string mode (int mode) {
            switch(mode) {
                case ECI : return "ECI"; break;
                case BYTE : return "BYTE"; break;
                case FNC1 : return "FNC1"; break;
                case KANJI : return "KANJI"; break;
                case NUMERIC : return "NUMERIC"; break;
                case ALPHANUM : return "ALPHANUM"; break;
                case STRUCTURED : return "STRUCTURED"; break;
                default : return ""; break;
            }
        }

        static std::string grid (const std::vector<std::vector<int>> &grid) {
            std::string os;
            for (int i = 0; i < grid.size(); i++) {
                for (int j = 0; j < grid.size(); j++) {
                    os += (grid[i][j] == 0) ? ". " : "# ";
                }
                os += '\n';
            }
            return os;
        }
        static std::string show (int ecc, int mode, int version) {
            std::string os;
            // std::cout << "codewords : " << ((capacity[version][mode][ecc] + 4) - msg.size()) << "\n";
            os += "Ecc : " + Infos::ECC(ecc) + "\n";
            os += "Mode : " + Infos::mode(mode) + "\n";
            os += "Version : " + std::to_string(version) + "\n";
            os += "Capacity : " + std::to_string(capacity[version][mode][ecc]) + "\n";
            return os;
            // std::cout << "data codewords : " << dc << " " << "error codewords : " << ec << "\n";
        }
};
